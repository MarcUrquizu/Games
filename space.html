<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mini Space Invaders (Canvas)</title>
  <style>
    html, body { margin:0; height:100%; background:#0b0f14; color:#e8eef7; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    .wrap { display:flex; align-items:center; justify-content:center; height:100%; }
    canvas { background:#05070a; border:1px solid #1d2a38; border-radius:10px; box-shadow: 0 12px 40px rgba(0,0,0,.5); touch-action: manipulation; }
    .hint { position:fixed; bottom:14px; left:50%; transform:translateX(-50%); opacity:.75; font-size:13px; text-align:center; padding:0 12px; }
    .hint kbd { background:#111a24; border:1px solid #223247; padding:2px 6px; border-radius:6px; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="800" height="600"></canvas>
  </div>
  <div class="hint">
    Mover: <kbd>‚Üê</kbd><kbd>‚Üí</kbd> o <kbd>A</kbd><kbd>D</kbd> ¬∑ Disparo auto ¬∑ <kbd>R</kbd> men√∫
  </div>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rectsIntersect = (a, b) =>
    a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;

  const W = canvas.width, H = canvas.height;
  const floorY = H - 70;
  const keys = new Set();

  // ===== Persistencia: desbloqueo Hardcore =====
  const LS_UNLOCK = "msi_unlocked_hardcore";
  const LS_LASTMODE = "msi_last_mode";
  const hasHardcoreUnlocked = () => localStorage.getItem(LS_UNLOCK) === "1";
  const setHardcoreUnlocked = () => localStorage.setItem(LS_UNLOCK, "1");

  // ===== Audio (beeps) =====
  let audioCtx = null;
  function ensureAudio() {
    if (audioCtx) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!AC) return;
    audioCtx = new AC();
  }
  function beep(freq = 140, dur = 0.08, type = "square", gain = 0.06) {
    try {
      ensureAudio();
      if (!audioCtx) return;
      if (audioCtx.state === "suspended") audioCtx.resume();

      const t0 = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();

      osc.type = type;
      osc.frequency.setValueAtTime(freq, t0);

      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(gain, t0 + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

      osc.connect(g);
      g.connect(audioCtx.destination);

      osc.start(t0);
      osc.stop(t0 + dur + 0.02);
    } catch {}
  }

  // ===== Screen shake =====
  const shake = { t: 0, mag: 0 };
  function triggerShake(mag = 7, dur = 0.16) {
    shake.t = Math.max(shake.t, dur);
    shake.mag = Math.max(shake.mag, mag);
  }
  function stopShake() { shake.t = 0; shake.mag = 0; }

  // ===== Modo actual =====
  const mode = { name: (localStorage.getItem(LS_LASTMODE) || "NORMAL") }; // NORMAL | HARDCORE

  // ===== Ajustes =====
  const tuning = {
    NORMAL: {
      enemyShootMul: 1.0,
      enemySpeedMul: 1.0,
      enemyBulletMul: 1.0,
      rapidDropChance: 0.10,
      shieldDropChance: 0.05,
      buddyDropChance: 0.003,
      dmgDropChance: 0.0006,
    },
    HARDCORE: {
      enemyShootMul: 1.35,
      enemySpeedMul: 1.15,
      enemyBulletMul: 1.15,
      rapidDropChance: 0.06,
      shieldDropChance: 0.035,
      buddyDropChance: 0.003,
      dmgDropChance: 0.0005,
    }
  };

  function currentTuning() { return tuning[mode.name] || tuning.NORMAL; }

  const state = {
    score: 0,
    lives: 3,
    maxLives: 3,
    wave: 1,
    status: "MENU", // MENU | PLAYING | GAME_OVER | GAME_WON
    maxWaves: 100,
  };

  const player = {
    x: W/2 - 20, y: H - 60,
    w: 40, h: 16,
    speed: 420,

    fireRate: 2.0,
    fireRateStep: 0.5,

    shield: 0,

    damage: 1,
    dmgUpgrades: 0,
    dmgUpgradesMax: 10,
  };

  // ===== Transici√≥n oleadas =====
  const transition = {
    active: false,
    t: 0,

    // ‚úÖ m√°s lento
    dur: 1.45,

    fromOffset: 260,
    labelT: 0,
    label: "",
  };
  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

  // ===== Balas jugador =====
  const playerBullets = [];

  // ===== Compa√±eros =====
  const buddies = []; // max 2
  function makeBuddy(slotIndex) { return { slotIndex, cooldown: 0 }; }

  // ===== Balas enemigas =====
  const enemyBullets = [];

  // ===== Powerups =====
  const powerups = [];
  const POWERUP_RAPID  = "RAPID";
  const POWERUP_SHIELD = "SHIELD";
  const POWERUP_BUDDY  = "BUDDY";
  const POWERUP_DMG    = "DMG";

  // ===== Explosiones =====
  const explosions = [];
  function spawnExplosion(x, y, big = false) {
    const dur = big ? 0.55 : 0.32;
    const n = big ? 30 : 16;
    const parts = [];
    for (let i = 0; i < n; i++) {
      const a = Math.random() * Math.PI * 2;
      const sp = (big ? 180 : 120) + Math.random() * (big ? 220 : 140);
      parts.push({ vx: Math.cos(a) * sp, vy: Math.sin(a) * sp, r: (big ? 3.0 : 2.2) + Math.random() * 2.2 });
    }
    explosions.push({ x, y, t: 0, dur, parts, big });
  }

  // ===== Enemigos normales =====
  const enemies = {
    rows: 5,
    cols: 10,
    padX: 14,
    padY: 14,
    cellW: 42,
    cellH: 26,
    top: 115,
    left: 90,

    dir: 1,
    speed: 55,
    dropStep: 18,
    shootChance: 0.006,
    alive: [],
  };

  // ===== Vida enemigos por tramos =====
  function hpRangeForWave(wave) {
    const tier = Math.floor((wave - 1) / 5) + 1; // 1..20
    return { minHp: tier, maxHp: tier + 1 };
  }

  // ===== Panel secreto (Ctrl+Q) =====
  function estimateProgressToWave(targetWave) {
    const t = currentTuning();
    const enemiesPerNormalWave = enemies.rows * enemies.cols;
    let normalWaves = 0;
    for (let w = 1; w < targetWave; w++) normalWaves++;
    const totalKills = normalWaves * enemiesPerNormalWave;

    const expectedRapid = totalKills * t.rapidDropChance;
    const approxFireRate = 2.0 + expectedRapid * player.fireRateStep;

    const lambdaBuddy = totalKills * t.buddyDropChance;
    const pGe1 = 1 - Math.exp(-lambdaBuddy);
    const pGe2 = 1 - (1 + lambdaBuddy) * Math.exp(-lambdaBuddy);
    const approxBuddies = clamp(Math.round(pGe1 + pGe2), 0, 2);

    const expectedDmg = totalKills * t.dmgDropChance;
    const approxDmgUp = clamp(Math.round(expectedDmg), 0, player.dmgUpgradesMax);
    const approxDamage = 1 + approxDmgUp;

    return { approxFireRate, approxBuddies, approxDamage };
  }

  const devPanel = document.createElement("div");
  devPanel.style.cssText = `
    position: fixed; right: 18px; top: 18px; z-index: 9999;
    width: 320px; padding: 12px; border-radius: 12px;
    background: rgba(10,14,20,.92);
    border: 1px solid rgba(120,150,200,.25);
    box-shadow: 0 12px 40px rgba(0,0,0,.55);
    display: none;
    color: #e8eef7;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
  `;
  devPanel.innerHTML = `
    <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
      <div style="font-weight:700;">Panel secreto</div>
      <button id="devClose" style="cursor:pointer;border-radius:10px;border:1px solid rgba(120,150,200,.25);background:#111a24;color:#e8eef7;padding:4px 10px;">X</button>
    </div>

    <div style="margin-top:10px;font-size:13px;opacity:.9;">Saltar a oleada (1‚Äì100)</div>
    <div style="display:flex; gap:8px; margin-top:8px;">
      <input id="devWave" type="number" min="1" max="100" value="1"
        style="flex:1;border-radius:10px;border:1px solid rgba(120,150,200,.25);background:#0b0f14;color:#e8eef7;padding:8px 10px;" />
      <button id="devGo" style="cursor:pointer;border-radius:10px;border:1px solid rgba(120,150,200,.25);background:#111a24;color:#e8eef7;padding:8px 10px;">Ir</button>
    </div>

    <div id="devEst" style="margin-top:10px;font-size:12px;opacity:.9;white-space:pre-line;line-height:1.35;">Estimaci√≥n: ‚Äî</div>
  `;
  document.body.appendChild(devPanel);

  let devOpen = false;
  function updateDevEstimate() {
    const w = clamp(Number(devPanel.querySelector("#devWave").value || 1), 1, state.maxWaves);
    const est = estimateProgressToWave(w);
    devPanel.querySelector("#devEst").textContent =
      `Estimaci√≥n al llegar a oleada ${w}:\n` +
      `‚Ä¢ cadencia ‚âà ${est.approxFireRate.toFixed(1)} disp/s\n` +
      `‚Ä¢ da√±o ‚âà ${est.approxDamage}\n` +
      `‚Ä¢ compa√±eros ‚âà ${est.approxBuddies}/2`;
  }
  function openDevPanel() {
    devOpen = true;
    devPanel.style.display = "block";
    devPanel.querySelector("#devWave").value = String(state.wave);
    updateDevEstimate();
  }
  function closeDevPanel() { devOpen = false; devPanel.style.display = "none"; }
  function toggleDevPanel() { devOpen ? closeDevPanel() : openDevPanel(); }

  function gotoWaveWithApprox(n) {
    const w = clamp(Math.floor(n || 1), 1, state.maxWaves);
    const est = estimateProgressToWave(w);

    player.fireRate = est.approxFireRate;
    buddies.length = 0;
    for (let i = 0; i < est.approxBuddies; i++) buddies.push(makeBuddy(i));

    const up = clamp(est.approxDamage - 1, 0, player.dmgUpgradesMax);
    player.dmgUpgrades = up;
    player.damage = 1 + up;

    player.shield = 0;
    state.lives = state.maxLives;

    playerBullets.length = 0;
    enemyBullets.length = 0;
    powerups.length = 0;
    explosions.length = 0;

    state.wave = w;
    state.status = "PLAYING";
    startTransitionToWave(w);
  }

  devPanel.querySelector("#devClose").addEventListener("click", closeDevPanel);
  devPanel.querySelector("#devWave").addEventListener("input", updateDevEstimate);
  devPanel.querySelector("#devGo").addEventListener("click", () => gotoWaveWithApprox(Number(devPanel.querySelector("#devWave").value)));

  // ===== Input =====
  window.addEventListener("keydown", (e) => {
    ensureAudio();
    if (e.ctrlKey && e.code === "KeyQ") { e.preventDefault(); toggleDevPanel(); return; }
    if (["ArrowLeft","ArrowRight","KeyA","KeyD","KeyR","Enter","Space"].includes(e.code)) e.preventDefault();
    keys.add(e.code);
    if (e.code === "KeyR") resetGame(true);
  }, { passive:false });
  window.addEventListener("keyup", (e) => keys.delete(e.code));

  canvas.addEventListener("mousedown", () => {
    ensureAudio();
    if (state.status === "MENU") startGameWithModeFromMenu(hasHardcoreUnlocked() ? mode.name : "NORMAL");
  });

  // ===== Disparo auto (PARA durante transici√≥n) =====
  function shootFrom(x, y, speed = -720, dmg = 1) {
    playerBullets.push({ x, y, w: 6, h: 12, vy: speed, dmg });
  }
  function autoFire(dt) {
    if (state.status !== "PLAYING") return;
    if (transition.active) return;

    player._cooldown = Math.max(0, (player._cooldown || 0) - dt);
    if (player._cooldown === 0) {
      shootFrom(player.x + player.w/2 - 3, player.y - 10, -720, player.damage);
      player._cooldown = 1 / player.fireRate;
    }

    for (let i = 0; i < buddies.length; i++) {
      const b = buddies[i];
      b.cooldown = Math.max(0, b.cooldown - dt);
      if (b.cooldown === 0) {
        const side = (b.slotIndex === 0) ? -1 : 1;
        const bx = player.x + player.w/2 + side * 34;
        const by = player.y - 6;
        shootFrom(bx - 3, by - 10, -700, player.damage);
        b.cooldown = 1 / player.fireRate;
      }
    }
  }

  // ===== UI corazones =====
  function drawHeart(x, y, size, filled) {
    const s = size;
    ctx.save();
    ctx.translate(x, y);
    ctx.beginPath();
    ctx.moveTo(s*0.5, s*0.25);
    ctx.bezierCurveTo(s*0.5, 0, s*0.1, 0, s*0.1, s*0.3);
    ctx.bezierCurveTo(s*0.1, s*0.55, s*0.45, s*0.75, s*0.5, s*0.95);
    ctx.bezierCurveTo(s*0.55, s*0.75, s*0.9, s*0.55, s*0.9, s*0.3);
    ctx.bezierCurveTo(s*0.9, 0, s*0.5, 0, s*0.5, s*0.25);
    ctx.closePath();
    if (filled) { ctx.fillStyle = "#ff4d7d"; ctx.fill(); }
    else { ctx.lineWidth = 2; ctx.strokeStyle = "#ff4d7d"; ctx.stroke(); }
    ctx.restore();
  }
  function drawShieldHeartFilled(x, y, size) {
    const s = size;
    ctx.save();
    ctx.translate(x, y);
    ctx.beginPath();
    ctx.moveTo(s*0.5, s*0.25);
    ctx.bezierCurveTo(s*0.5, 0, s*0.1, 0, s*0.1, s*0.3);
    ctx.bezierCurveTo(s*0.1, s*0.55, s*0.45, s*0.75, s*0.5, s*0.95);
    ctx.bezierCurveTo(s*0.55, s*0.75, s*0.9, s*0.55, s*0.9, s*0.3);
    ctx.bezierCurveTo(s*0.9, 0, s*0.5, 0, s*0.5, s*0.25);
    ctx.closePath();
    ctx.fillStyle = "#4aa8ff";
    ctx.fill();
    ctx.restore();
  }

  // ===== Powerups =====
  function trySpawnPowerupAt(x, y, type) {
    powerups.push({ x: x - 18, y: y - 13, w: 36, h: 24, vy: 155, type });
  }
  function applyPowerup(type) {
    if (type === POWERUP_RAPID) {
      player.fireRate += 0.5;
      beep(520, 0.05, "triangle", 0.04);
    } else if (type === POWERUP_SHIELD) {
      player.shield = 3;
      beep(260, 0.07, "sine", 0.05);
    } else if (type === POWERUP_BUDDY) {
      if (buddies.length < 2) { buddies.push(makeBuddy(buddies.length)); beep(640, 0.06, "triangle", 0.04); }
    } else if (type === POWERUP_DMG) {
      if (player.dmgUpgrades >= player.dmgUpgradesMax) return;
      player.dmgUpgrades += 1;
      player.damage = 1 + player.dmgUpgrades;
      beep(880, 0.07, "square", 0.045);
      beep(660, 0.05, "triangle", 0.03);
    }
  }

  // ===== Disparo enemigo =====
  function spawnEnemyBullet(x, y, vx, vy) {
    const t = currentTuning();
    enemyBullets.push({ x, y, w: 6, h: 12, vx: (vx||0)*t.enemyBulletMul, vy: (vy||215)*t.enemyBulletMul });
  }

  // ===== Sprite unificado (enemigos y powerups) =====
  function drawInvaderBody(x, y, w, h, bodyColor) {
    ctx.fillStyle = bodyColor;
    ctx.fillRect(x, y, w, h);

    ctx.fillStyle = "rgba(255,255,255,.08)";
    ctx.fillRect(x + 2, y + 2, w - 4, 3);

    const eyeW = Math.max(4, Math.floor(w * 0.16));
    const eyeH = eyeW;
    const eyeY = y + Math.floor(h * 0.32);
    const leftEyeX  = x + Math.floor(w * 0.28) - Math.floor(eyeW/2);
    const rightEyeX = x + Math.floor(w * 0.72) - Math.floor(eyeW/2);

    ctx.fillStyle = "rgba(0,0,0,.45)";
    ctx.fillRect(leftEyeX,  eyeY, eyeW, eyeH);
    ctx.fillRect(rightEyeX, eyeY, eyeW, eyeH);
  }

  const GLYPHS = {
    RAPID:  ["00100","01110","10101","00100","00100"],
    SHIELD: ["01110","11111","11111","01110","00100"],
    BUDDY:  ["00000","01010","00000","01010","00000"],
    DMG:    ["00100","00100","11111","00100","00100"],
  };

  function drawGlyph(type, x, y, w, h) {
    const g = GLYPHS[type];
    if (!g) return;

    const cols = 5, rows = 5;
    const cell = Math.floor(Math.min(w/cols, h/rows));
    const gw = cell * cols;
    const gh = cell * rows;

    const sx = x + Math.floor((w - gw)/2);
    const sy = y + Math.floor((h - gh)/2) + 3;

    ctx.fillStyle = "rgba(0,0,0,.45)";
    for (let r = 0; r < rows; r++) {
      const line = g[r];
      for (let c = 0; c < cols; c++) {
        if (line[c] === "1") ctx.fillRect(sx + c*cell, sy + r*cell, cell-1, cell-1);
      }
    }
  }

  function powerupColor(type) {
    if (type === POWERUP_RAPID) return "rgba(255, 214, 107, .95)";
    if (type === POWERUP_SHIELD) return "rgba(74, 168, 255, .92)";
    if (type === POWERUP_BUDDY) return "rgba(184, 255, 138, .92)";
    return "rgba(255, 120, 40, .92)";
  }

  // ===== Init enemigos =====
  function initEnemiesForWave(wave, spawnFromTop) {
    enemies.alive = [];
    enemies.dir = 1;

    const t = currentTuning();
    enemies.speed = (50 + (wave - 1) * 3.2) * t.enemySpeedMul;
    enemies.shootChance = (0.0042 + (wave - 1) * 0.00026) * t.enemyShootMul;

    const { minHp } = hpRangeForWave(wave);

    for (let r = 0; r < enemies.rows; r++) {
      for (let c = 0; c < enemies.cols; c++) {
        const hpMaxLocal = minHp + (Math.random() < 0.5 ? 0 : 1);
        const targetY = enemies.top + r * (enemies.cellH + enemies.padY);
        const startY  = targetY - transition.fromOffset;

        enemies.alive.push({
          r, c,
          x: enemies.left + c * (enemies.cellW + enemies.padX),
          y: spawnFromTop ? startY : targetY,
          targetY,
          startY,
          w: enemies.cellW,
          h: enemies.cellH,
          alive: true,
          hp: hpMaxLocal,
          hpMax: hpMaxLocal,
          tierMinHp: minHp,
        });
      }
    }
  }

  function startTransitionToWave(wave) {
    // ‚úÖ SOLO desaparecen balas que est√©n en el campo
    playerBullets.length = 0;
    enemyBullets.length = 0;

    transition.active = true;
    transition.t = 0;
    transition.labelT = 0;
    transition.label = `OLEADA ${wave}`;

    initEnemiesForWave(wave, true);
  }

  function completeWaveAndTransition() {
    const next = state.wave + 1;
    if (next > state.maxWaves) {
      state.status = "GAME_WON";
      setHardcoreUnlocked();
      beep(520, 0.12, "triangle", 0.05);
      return;
    }
    state.wave = next;
    startTransitionToWave(next);
  }

  // ===== Reset / start =====
  function resetGame(toMenu = true) {
    state.score = 0;
    state.lives = 3;
    state.wave = 1;

    player.fireRate = 2.0;
    player.shield = 0;
    player.damage = 1;
    player.dmgUpgrades = 0;

    buddies.length = 0;
    playerBullets.length = 0;
    enemyBullets.length = 0;
    powerups.length = 0;
    explosions.length = 0;
    enemies.alive = [];
    transition.active = false;

    stopShake();
    state.status = toMenu ? "MENU" : "PLAYING";
  }

  function startGameWithModeFromMenu(m) {
    mode.name = m;
    localStorage.setItem(LS_LASTMODE, m);

    resetGame(false);
    state.status = "PLAYING";
    state.wave = 1;
    startTransitionToWave(1);
  }

  // ===== Input =====
  window.addEventListener("keydown", (e) => {
    ensureAudio();
    if (e.ctrlKey && e.code === "KeyQ") { e.preventDefault(); toggleDevPanel(); return; }
    if (["ArrowLeft","ArrowRight","KeyA","KeyD","KeyR","Enter","Space"].includes(e.code)) e.preventDefault();
    keys.add(e.code);
    if (e.code === "KeyR") resetGame(true);
  }, { passive:false });
  window.addEventListener("keyup", (e) => keys.delete(e.code));

  // ===== Update =====
  let last = performance.now();
  function update(dt) {
    if (shake.t > 0) {
      shake.t = Math.max(0, shake.t - dt);
      shake.mag = Math.max(0, shake.mag - dt * 18);
    }

    for (let i = explosions.length - 1; i >= 0; i--) {
      explosions[i].t += dt;
      if (explosions[i].t >= explosions[i].dur) explosions.splice(i, 1);
    }

    if (state.status !== "PLAYING") return;

    // moverte siempre
    const left = (keys.has("ArrowLeft") || keys.has("KeyA")) ? 1 : 0;
    const right = (keys.has("ArrowRight") || keys.has("KeyD")) ? 1 : 0;
    player.x = clamp(player.x + (right - left) * player.speed * dt, 12, W - player.w - 12);

    // auto-disparo (parado durante transici√≥n)
    autoFire(dt);

    // transici√≥n (bajan)
    if (transition.active) {
      transition.t = Math.min(transition.dur, transition.t + dt);
      transition.labelT = Math.min(1, transition.labelT + dt * 1.8);

      const p = easeOutCubic(transition.t / transition.dur);
      for (const e of enemies.alive) {
        if (!e.alive) continue;
        e.y = e.startY + (e.targetY - e.startY) * p;
        if (transition.t >= transition.dur) e.y = e.targetY;
      }

      if (transition.t >= transition.dur) {
        transition.active = false;
        transition.t = 0;
      }
    }

    // bullets jugador
    for (let i = playerBullets.length - 1; i >= 0; i--) {
      const b = playerBullets[i];
      b.y += b.vy * dt;
      if (b.y + b.h < 0) playerBullets.splice(i, 1);
    }

    // powerups
    for (let i = powerups.length - 1; i >= 0; i--) {
      const p = powerups[i];
      p.y += p.vy * dt;
      if (rectsIntersect(p, player)) { applyPowerup(p.type); powerups.splice(i, 1); continue; }
      if (p.y > H + 30) powerups.splice(i, 1);
    }

    const aliveEnemies = enemies.alive.filter(e => e.alive);

    if (aliveEnemies.length === 0 && !transition.active) {
      completeWaveAndTransition();
      return;
    }

    // enemigos: solo se mueven/disparan si NO transici√≥n
    if (!transition.active && aliveEnemies.length) {
      let minX = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const e of aliveEnemies) {
        minX = Math.min(minX, e.x);
        maxX = Math.max(maxX, e.x + e.w);
        maxY = Math.max(maxY, e.y + e.h);
      }

      const step = enemies.dir * enemies.speed * dt;
      for (const e of aliveEnemies) e.x += step;

      const margin = 14;
      if (minX + step < margin || maxX + step > W - margin) {
        enemies.dir *= -1;
        for (const e of aliveEnemies) e.y += enemies.dropStep;
      }

      if (maxY >= floorY) { state.status = "GAME_OVER"; triggerShake(16, 0.6); beep(85, 0.14); return; }

      const shootersByCol = new Map();
      for (const e of aliveEnemies) {
        const prev = shootersByCol.get(e.c);
        if (!prev || e.y > prev.y) shootersByCol.set(e.c, e);
      }
      const shooters = [...shootersByCol.values()];
      for (const s of shooters) {
        if (Math.random() < enemies.shootChance * dt * 60) {
          spawnEnemyBullet(s.x + s.w/2 - 3, s.y + s.h + 2, 0, 205 + state.wave * 1.6);
        }
      }
    }

    // colisiones bala jugador vs enemigos + drops
    const t = currentTuning();
    for (let i = playerBullets.length - 1; i >= 0; i--) {
      const b = playerBullets[i];
      let hit = false;

      for (const e of enemies.alive) {
        if (!e.alive) continue;
        if (rectsIntersect(b, e)) {
          hit = true;
          e.hp -= b.dmg;

          if (e.hp <= 0) {
            e.alive = false;
            state.score += 10;
            spawnExplosion(e.x + e.w/2, e.y + e.h/2, false);

            if (buddies.length < 2 && Math.random() < t.buddyDropChance) trySpawnPowerupAt(e.x + e.w/2, e.y + e.h/2, POWERUP_BUDDY);
            if (player.shield === 0 && Math.random() < t.shieldDropChance) trySpawnPowerupAt(e.x + e.w/2, e.y + e.h/2, POWERUP_SHIELD);
            if (Math.random() < t.rapidDropChance) trySpawnPowerupAt(e.x + e.w/2, e.y + e.h/2, POWERUP_RAPID);
            if (player.dmgUpgrades < player.dmgUpgradesMax && Math.random() < t.dmgDropChance) trySpawnPowerupAt(e.x + e.w/2, e.y + e.h/2, POWERUP_DMG);
          }
          break;
        }
      }

      if (hit) playerBullets.splice(i, 1);
    }

    // bullets enemigos
    for (let i = enemyBullets.length - 1; i >= 0; i--) {
      const b = enemyBullets[i];
      b.x += (b.vx || 0) * dt;
      b.y += (b.vy || 0) * dt;

      if (b.y > H + 40 || b.x < -60 || b.x > W + 60) { enemyBullets.splice(i, 1); continue; }

      if (rectsIntersect(b, player)) {
        enemyBullets.splice(i, 1);
        if (player.shield > 0) { player.shield--; triggerShake(7, 0.14); beep(170, 0.06, "sine", 0.05); }
        else {
          state.lives--;
          triggerShake(9, 0.15);
          beep(110, 0.08, "square", 0.07);
          if (state.lives <= 0) { state.status = "GAME_OVER"; triggerShake(16, 0.6); beep(85, 0.14); }
        }
      }
    }
  }

  // ===== Draw =====
  function drawInvaderBody(x, y, w, h, bodyColor) {
    ctx.fillStyle = bodyColor;
    ctx.fillRect(x, y, w, h);

    ctx.fillStyle = "rgba(255,255,255,.08)";
    ctx.fillRect(x + 2, y + 2, w - 4, 3);

    const eyeW = Math.max(4, Math.floor(w * 0.16));
    const eyeH = eyeW;
    const eyeY = y + Math.floor(h * 0.32);
    const leftEyeX  = x + Math.floor(w * 0.28) - Math.floor(eyeW/2);
    const rightEyeX = x + Math.floor(w * 0.72) - Math.floor(eyeW/2);

    ctx.fillStyle = "rgba(0,0,0,.45)";
    ctx.fillRect(leftEyeX,  eyeY, eyeW, eyeH);
    ctx.fillRect(rightEyeX, eyeY, eyeW, eyeH);
  }

  function draw() {
    let ox = 0, oy = 0;
    if (shake.t > 0) {
      const m = shake.mag;
      ox = (Math.random() * 2 - 1) * m;
      oy = (Math.random() * 2 - 1) * m;
    }

    ctx.save();
    ctx.translate(ox, oy);

    ctx.clearRect(-ox, -oy, W, H);
    ctx.fillStyle = "#05070a";
    ctx.fillRect(0, 0, W, H);

    ctx.globalAlpha = 0.35;
    ctx.fillStyle = "#c7d7ff";
    for (let i = 0; i < 70; i++) ctx.fillRect((i * 97) % W, (i * 53) % H, 2, 2);
    ctx.globalAlpha = 1;

    ctx.strokeStyle = "#182434";
    ctx.beginPath();
    ctx.moveTo(0, floorY);
    ctx.lineTo(W, floorY);
    ctx.stroke();

    ctx.fillStyle = "#e8eef7";
    ctx.font = "16px system-ui, sans-serif";
    ctx.fillText(`Puntuaci√≥n: ${state.score}`, 16, 26);
    ctx.fillText(`Oleada: ${state.wave}/${state.maxWaves}`, 16, 48);
    ctx.globalAlpha = 0.85;
    ctx.fillText(`Modo: ${mode.name}`, 16, 70);
    ctx.fillText(`Cadencia: ${player.fireRate.toFixed(1)} disp/s`, 16, 92);
    ctx.fillText(`Da√±o: ${player.damage}  (+${player.dmgUpgrades}/${player.dmgUpgradesMax})`, 16, 114);
    ctx.globalAlpha = 1;

    const startX = W - 16 - (state.maxLives * 28);
    const baseY = 12;
    for (let i = 0; i < state.maxLives; i++) drawHeart(startX + i * 28, baseY, 22, i < state.lives);
    const shieldY = baseY + 26;
    for (let i = 0; i < player.shield; i++) drawShieldHeartFilled(startX + i * 28, shieldY, 22);

    ctx.fillStyle = "#8bd3ff";
    ctx.fillRect(player.x, player.y, player.w, player.h);
    ctx.fillRect(player.x + 6, player.y - 10, player.w - 12, 10);
    ctx.fillStyle = "#d3f3ff";
    ctx.fillRect(player.x + player.w/2 - 4, player.y - 16, 8, 6);

    for (let i = 0; i < buddies.length; i++) {
      const b = buddies[i];
      const side = (b.slotIndex === 0) ? -1 : 1;
      const bx = player.x + player.w/2 + side * 34;
      const by = player.y - 10;
      drawInvaderBody(bx - 14, by, 28, 18, "rgba(184,255,138,.92)");
    }

    ctx.fillStyle = "#d0ff6b";
    for (const b of playerBullets) ctx.fillRect(b.x, b.y, b.w, b.h);

    for (const e of enemies.alive) {
      if (!e.alive) continue;
      const color = (e.hpMax > e.tierMinHp) ? "#ff3b3b" : `hsl(${160 + e.r * 18} 70% 55%)`;
      drawInvaderBody(e.x, e.y, e.w, e.h, color);
    }

    ctx.fillStyle = "#ff6b9e";
    for (const b of enemyBullets) ctx.fillRect(b.x, b.y, b.w, b.h);

    for (const p of powerups) {
      drawInvaderBody(p.x, p.y, p.w, p.h, powerupColor(p.type));
      drawGlyph(p.type, p.x, p.y, p.w, p.h);
    }

    for (const ex of explosions) {
      const p = clamp(ex.t / ex.dur, 0, 1);
      const a = 1 - p;

      ctx.globalAlpha = a * 0.55;
      ctx.strokeStyle = "#ffd66b";
      ctx.lineWidth = ex.big ? 3 : 2;
      ctx.beginPath();
      ctx.arc(ex.x, ex.y, (ex.big ? 10 : 6) + p * (ex.big ? 90 : 55), 0, Math.PI * 2);
      ctx.stroke();

      ctx.globalAlpha = a;
      ctx.fillStyle = "#ffd66b";
      for (const prt of ex.parts) {
        const px = ex.x + prt.vx * ex.t * 0.012;
        const py = ex.y + prt.vy * ex.t * 0.012;
        ctx.beginPath();
        ctx.arc(px, py, prt.r * (1 - p * 0.7), 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    if (transition.active) {
      const a = clamp(transition.labelT, 0, 1);
      ctx.globalAlpha = 0.55 * a;
      ctx.fillStyle = "rgba(0,0,0,.55)";
      ctx.fillRect(0, 0, W, 86);
      ctx.globalAlpha = 1;
      ctx.fillStyle = "#ffffff";
      ctx.font = "bold 28px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.globalAlpha = 0.95 * a;
      ctx.fillText(transition.label, W/2, 54);
      ctx.globalAlpha = 1;
      ctx.textAlign = "start";
    }

    if (state.status !== "PLAYING") {
      ctx.fillStyle = "rgba(0,0,0,.58)";
      ctx.fillRect(0, 0, W, H);

      ctx.fillStyle = "#ffffff";
      ctx.textAlign = "center";

      if (state.status === "MENU") {
        ctx.font = "bold 44px system-ui, sans-serif";
        ctx.fillText("MINI SPACE INVADERS", W/2, H/2 - 70);
        ctx.font = "18px system-ui, sans-serif";
        ctx.globalAlpha = 0.9;
        ctx.fillText("Pulsa ENTER o clic para empezar", W/2, H/2 - 30);
        ctx.globalAlpha = 1;
      } else if (state.status === "GAME_OVER") {
        ctx.font = "bold 52px system-ui, sans-serif";
        ctx.fillText("GAME OVER", W/2, H/2 - 30);
        ctx.font = "18px system-ui, sans-serif";
        ctx.fillText("Pulsa R para volver al men√∫", W/2, H/2 + 18);
      } else if (state.status === "GAME_WON") {
        ctx.font = "bold 50px system-ui, sans-serif";
        ctx.fillText("¬°HAS GANADO!", W/2, H/2 - 65);
        ctx.font = "22px system-ui, sans-serif";
        ctx.fillText("Enhorabuena üí´ Has completado las 100 oleadas.", W/2, H/2 - 30);
        ctx.font = "18px system-ui, sans-serif";
        ctx.globalAlpha = 0.95;
        ctx.fillText("Pulsa R para volver al men√∫", W/2, H/2 + 16);
        ctx.globalAlpha = 1;
      }

      ctx.textAlign = "start";
    }

    ctx.restore();
  }

  function loop(t) {
    const dt = Math.min(0.033, (t - last) / 1000);
    last = t;

    if (state.status === "MENU") {
      if (keys.has("Enter") || keys.has("Space")) {
        keys.delete("Enter"); keys.delete("Space");
        startGameWithModeFromMenu(hasHardcoreUnlocked() ? mode.name : "NORMAL");
      }
    }

    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  resetGame(true);
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
